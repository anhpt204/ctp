# GA + Local Search

import array
import random
import json

import numpy

from deap import algorithms
from deap import base
from deap import creator
from deap import tools

from problem import CTPProblem
from util import split, extract_tours, get_cost, concat
from os.path import join

from setting import *
from math import fabs
from ls_moves import *
from deap.algorithms import varOr, eaSimple

# load problem
# data_path = '/home/pta/projects/ctp/data_ctp/kroA-13-12-75-4.ctp'
problem = CTPProblem()
# problem.load_data(data_path)
toolbox = base.Toolbox()
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", array.array, typecode='i', fitness=creator.FitnessMin, giant_tour=list, tours=list)

move_operators = [move1, move2, move3, move4, move5, move6, move7, move8, move9]

def initialize():
    # ignore depot
    IND_SIZE = problem.num_of_nodes + len(problem.obligatory_nodes) -1



    # Attribute generator
    toolbox.register("indices", random.sample, range(1,IND_SIZE+1), IND_SIZE)
    
    # Structure initializers
    toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.indices)
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)
                    
def get_giant_tour(individual):
    '''
    scan from left to right to extract a giant tour
    '''
    giant_tour = []
    i = 0
    covering_set = set()
    
    while True:
        node_id = individual[i]
        i += 1
        # check if node belong to obligatory nodes
        if problem.obligatory_nodes.issuperset(set([node_id])):
            giant_tour.append(node_id)
            continue
        
        covered_customers = problem.get_set_of_customers_covered_by(node_id)
        
        if covered_customers.issubset(covering_set):
            continue
        
        # update tour
        giant_tour.append(node_id)
        
        # update covering set
        covering_set = covering_set.union(covered_customers)
        
        if len(covering_set) == problem.num_of_customers:
            break
    
    # append all remaining nodes in individual that also in obligatory nodes into tour
    for node_id in individual[i:]:
        if problem.obligatory_nodes.issuperset(set([node_id])):
            giant_tour.append(node_id)
            
    individual.giant_tour = giant_tour
    
    return giant_tour
    
def get_giant_tours(individual):
    '''
    get giant tours of an individual
    try MAX_TRAILS times
    '''
    giant_tours =[]
#     MAX_TRAILS = 20
    for start_i in xrange(MAX_TRAILS):
        # get tour
        covering_set = set()
        tour = []
        
        # append nodes before start_i that in T into tour
        for node_id in individual[:start_i]:
            if problem.obligatory_nodes.issuperset(set([node_id])):
                tour.append(node_id)

        i = start_i
        while True:
            # infeasible
            if i >= len(individual):
                return giant_tours
            
            node_id = individual[i]
            i+=1
            # check if node belong to obligatory nodes
            if problem.obligatory_nodes.issuperset(set([node_id])):
                tour.append(node_id)
                continue
            
            covered_customers = problem.get_set_of_customers_covered_by(node_id)
            
            if covered_customers.issubset(covering_set):
                continue
            
            # update tour
            tour.append(node_id)
            
            # update covering set
            covering_set = covering_set.union(covered_customers)
            
            if len(covering_set) == problem.num_of_customers:
                break
            
            
            
        # append all remaining nodes in individual that also in obligatory nodes into tour
        for node_id in individual[i:]:
            if problem.obligatory_nodes.issuperset(set([node_id])):
                tour.append(node_id)

        giant_tours.append(tour)
        
    return giant_tours

def is_valid_solution(tours):
    '''
    check constraints of a solution
    '''
    # check tour length
    for tour in tours:
        if len(tour) > problem.max_nodes_per_route:
            return False
    return True
        
# local search
def local_search(individual):
    '''
    A Simple and Effective Evolutionary Algorithm for the Vehicle Routing Problem, Prins, 2001
    '''
    tours_len = len(individual.tours)
    tours = individual.tours
    best_cost = individual.fitness.values[0]
    best_tours = individual.tours
    
    for tour_i in xrange(tours_len):
        tour1_tmp = [0] + tours[tour_i] + [0]
        for i in xrange(len(tour1_tmp) -1):
            u, x = tour1_tmp[i], tour1_tmp[i+1]
            for tour_j in xrange(tours_len):
                tour2_tmp = [0] + tours[tour_j] +  [0]
                for j in xrange(len(tour2_tmp) - 1):
                    v, y = tour2_tmp[j], tour2_tmp[j+1]
                    # move operators
                    for move in move_operators:
                        move_success, temp_tours = move(individual, tour_i, tour_j, i, j, u, v, x, y)
                        
                        
                        if move_success and is_valid_solution(temp_tours):
#                             print tour_i, tour_j, i, j, temp_tours
                            cost = get_cost(problem, temp_tours)
                            # if improvement
                            if cost < best_cost:
                                best_cost = cost
                                best_tours = temp_tours[:]
                                continue
                    
    individual.tours = best_tours[:]
    old_giant_tour = individual.giant_tour
    new_giant_tour = concat(best_tours)
    changes = {}
    for k, v in zip(old_giant_tour, new_giant_tour):
        changes[k] = v       
    
    # change individual response to new giant tour
    for i in xrange(len(individual)):
        k = individual[i]
        if changes.has_key(k):
            individual[i] = changes[k]
    
    individual.giant_tour = new_giant_tour
    individual.fitness.values = best_cost,
    
    return individual 
                                     
    
# evaluate solution
def eval(individual):
    
    best_cost = 10**10
    best_tour = None
    best_backtrack = None
    # get giant tours of an individual
    giant_tours = get_giant_tours(individual)
    # get the best giant tour
    for giant_tour in giant_tours:    
        cost, backtrack = split(problem, giant_tour)
        if cost < best_cost:
            best_cost = cost
            best_tour = giant_tour[:]
            best_backtrack = backtrack[:]
                    
    # split tour and return total cost
    tours = extract_tours(best_tour, best_backtrack)
    
    individual.tours = tours

    individual.giant_tour = best_tour
        
    return cost,

def computeFitness(individual):
    best_cost = 10**10
    best_tour = None
    best_backtrack = None
    # get giant tours of an individual
    giant_tours = get_giant_tours(individual)
    # get the best giant tour
    for giant_tour in giant_tours:    
        cost, backtrack = split(problem, giant_tour)
        if cost < best_cost:
            best_cost = cost
            best_tour = giant_tour[:]
            best_backtrack = backtrack[:]
                    
    # split tour and return total cost
    tours = extract_tours(best_tour, best_backtrack)
    
    individual.tours = tours

    individual.giant_tour = best_tour
    # assign to individual
    individual.fitness.values = best_cost,
    individual.tours = tours

def mutLS(individual):
    """
    Local Search
    
    :param individual: Individual to be mutated.
    :param indpb: Independent probability for each attribute to be exchanged to
                  another position.
    :returns: A tuple of one individual.
    
    This function uses the :func:`~random.random` and :func:`~random.randint`
    functions from the python base :mod:`random` module.
    """
    if not individual.fitness.valid:
        computeFitness(individual)
    
    individual = local_search(individual)
    
    return individual,

def varAndPTA(population, toolbox, cxpb, mutpb, lspb):
    """
    """
    offspring = [toolbox.clone(ind) for ind in population]
    
    # Apply crossover and mutation on the offspring
    for i in range(1, len(offspring), 2):
        if random.random() < cxpb:
            offspring[i-1], offspring[i] = toolbox.mate(offspring[i-1], offspring[i])
            del offspring[i-1].fitness.values, offspring[i].fitness.values
            
        if random.random() < mutpb:
            offspring[i-1], = toolbox.mutate(offspring[i-1])
            del offspring[i-1].fitness.values
        
        if random.random() < mutpb:
            offspring[i], = toolbox.mutate(offspring[i])
            del offspring[i].fitness.values
            
        if random.random() < lspb:
            offspring[i-1], = toolbox.ls(offspring[i-1])
            
        if random.random() < lspb:
            offspring[i], = toolbox.ls(offspring[i])
            
    
    return offspring

def eaPTA(population, toolbox, cxpb, mutpb, lspb, ngen, stats=None,
             halloffame=None, verbose=__debug__):
    """This algorithm reproduce the simplest evolutionary algorithm as
    presented in chapter 7 of [Back2000]_.
    
    :param population: A list of individuals.
    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution
                    operators.
    :param cxpb: The probability of mating two individuals.
    :param mutpb: The probability of mutating an individual.
    :param ngen: The number of generation.
    :param stats: A :class:`~deap.tools.Statistics` object that is updated
                  inplace, optional.
    :param halloffame: A :class:`~deap.tools.HallOfFame` object that will
                       contain the best individuals, optional.
    :param verbose: Whether or not to log the statistics.
    :returns: The final population and a :class:`~deap.tools.Logbook`
              with the statistics of the evolution.
    
    The algorithm takes in a population and evolves it in place using the
    :meth:`varAnd` method. It returns the optimized population and a
    :class:`~deap.tools.Logbook` with the statistics of the evolution (if
    any). The logbook will contain the generation number, the number of
    evalutions for each generation and the statistics if a
    :class:`~deap.tools.Statistics` if any. The *cxpb* and *mutpb* arguments
    are passed to the :func:`varAnd` function. The pseudocode goes as follow
    ::

        evaluate(population)
        for g in range(ngen):
            population = select(population, len(population))
            offspring = varAnd(population, toolbox, cxpb, mutpb)
            evaluate(offspring)
            population = offspring

    As stated in the pseudocode above, the algorithm goes as follow. First, it
    evaluates the individuals with an invalid fitness. Second, it enters the
    generational loop where the selection procedure is applied to entirely
    replace the parental population. The 1:1 replacement ratio of this
    algorithm **requires** the selection procedure to be stochastic and to
    select multiple times the same individual, for example,
    :func:`~deap.tools.selTournament` and :func:`~deap.tools.selRoulette`.
    Third, it applies the :func:`varAnd` function to produce the next
    generation population. Fourth, it evaluates the new individuals and
    compute the statistics on this population. Finally, when *ngen*
    generations are done, the algorithm returns a tuple with the final
    population and a :class:`~deap.tools.Logbook` of the evolution.

    .. note::

        Using a non-stochastic selection method will result in no selection as
        the operator selects *n* individuals from a pool of *n*.
    
    This function expects the :meth:`toolbox.mate`, :meth:`toolbox.mutate`,
    :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be
    registered in the toolbox.
    
    .. [Back2000] Back, Fogel and Michalewicz, "Evolutionary Computation 1 :
       Basic Algorithms and Operators", 2000.
    """
    logbook = tools.Logbook()
    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])

    # Evaluate the individuals with an invalid fitness
    invalid_ind = [ind for ind in population if not ind.fitness.valid]
    fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
    for ind, fit in zip(invalid_ind, fitnesses):
        ind.fitness.values = fit

    if halloffame is not None:
        halloffame.update(population)

    record = stats.compile(population) if stats else {}
    logbook.record(gen=0, nevals=len(invalid_ind), **record)
    if verbose:
        print logbook.stream

    # Begin the generational process
    for gen in range(1, ngen+1):
        # Select the next generation individuals
        offspring = toolbox.select(population, len(population))
        
        # Vary the pool of individuals
        offspring = varAndPTA(offspring, toolbox, cxpb, mutpb, lspb)
        
        # Evaluate the individuals with an invalid fitness
        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit
        
        # Update the hall of fame with the generated individuals
        if halloffame is not None:
            halloffame.update(offspring)
            
        # Replace the current population by the offspring
        population[:] = offspring
        
        # Append the current generation statistics to the logbook
        record = stats.compile(population) if stats else {}
        logbook.record(gen=gen, nevals=len(invalid_ind), **record)
        if verbose:
            print logbook.stream        

    return population, logbook

def PMX(ind1, ind2):
    """Executes a partially matched crossover (PMX) on the input individuals.
    The two individuals are modified in place. This crossover expects
    :term:`sequence` individuals of indices, the result for any other type of
    individuals is unpredictable.
    
    :param ind1: The first individual participating in the crossover.
    :param ind2: The second individual participating in the crossover.
    :returns: A tuple of two individuals.

    Moreover, this crossover generates two children by matching
    pairs of values in a certain range of the two parents and swapping the values
    of those indexes. For more details see [Goldberg1985]_.

    This function uses the :func:`~random.randint` function from the python base
    :mod:`random` module.
    
    .. [Goldberg1985] Goldberg and Lingel, "Alleles, loci, and the traveling
       salesman problem", 1985.
    """
    size = min(len(ind1), len(ind2))
    p1, p2 = [0]*(size+1), [0]*(size+1)

    # Initialize the position of each indices in the individuals
    for i in xrange(size):
        p1[ind1[i]] = i
        p2[ind2[i]] = i
    # Choose crossover points
    cxpoint1 = random.randint(0, size)
    cxpoint2 = random.randint(0, size - 1)
    if cxpoint2 >= cxpoint1:
        cxpoint2 += 1
    else: # Swap the two cx points
        cxpoint1, cxpoint2 = cxpoint2, cxpoint1
    
    # Apply crossover between cx points
    for i in xrange(cxpoint1, cxpoint2):
        # Keep track of the selected values
        temp1 = ind1[i]
        temp2 = ind2[i]
        # Swap the matched value
        ind1[i], ind1[p1[temp2]] = temp2, temp1
        ind2[i], ind2[p2[temp1]] = temp1, temp2
        # Position bookkeeping
        p1[temp1], p1[temp2] = p1[temp2], p1[temp1]
        p2[temp1], p2[temp2] = p2[temp2], p2[temp1]
    
    return ind1, ind2

toolbox.register("mate", PMX)
toolbox.register("ls", mutLS)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", eval)


def run(job=0):
    random.seed(1000+job)

    pop = toolbox.population(n=POPSIZE)

    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean)
    stats.register("std", numpy.std)
    stats.register("min", numpy.min)
    stats.register("max", numpy.max)
    
    eaPTA(pop, toolbox, PCROSS, PMUTATION, PLOCALSEARCH, NUM_GEN, stats=stats, 
                        halloffame=hof, verbose=VERBOSE)
    
    print 'run ', job, ': ', hof[0].fitness.values[0], ': ', problem.best_cost
    
    print hof[0].giant_tour
    
    return hof[0].fitness.values[0]

import glob, os, datetime
if __name__ == "__main__":
    # load problem
    data_dir = '/home/pta/projects/ctp/data_ctp/A/A24/'
    
    files = glob.glob(data_dir + '*.ctp')
    lines = []
    
#    files = [os.path.join(data_dir, 'A2-10-50-150-6.ctp')]
    
    for file in files:
        time1 = datetime.datetime.now()
        file_name = os.path.basename(file)
        print file_name
        problem.load_data(file)
        initialize()
        
        best_x =[]
        for job in xrange(JOBS):
            best_cost = run(job)
            best_x.append(best_cost)
            
        time2 = datetime.datetime.now()
        
        lines.append( file_name + " " + str(min(best_x)) + " " + str(problem.best_cost) + " " + str(time2-time1) + '\n')

    open('resultA24.txt', 'w').writelines(lines)
